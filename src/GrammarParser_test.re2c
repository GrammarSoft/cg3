/*
 * Copyright (C) 2006, GrammarSoft Aps
 * and the VISL project at the University of Southern Denmark.
 * All Rights Reserved.
 *
 * The contents of this file are subject to the GrammarSoft Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.grammarsoft.com/GSPL or
 * http://visl.sdu.dk/GSPL.txt
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 */

#include "stdafx.h"
#include "Strings.h"
#include <unicode/uregex.h>
#include "GrammarParser.h"
#include "Grammar.h"
#include "uextras.h"
#include <sys/stat.h>

using namespace CG3;
using namespace CG3::Strings;

/*!re2c
re2c:yyfill:enable = 0 ;

newline = [\n\u2028\u2029\x85\x0C];
space = [ \t\r\x0B\x0D\u001C\u001D\u001E\u001F];
any = [^];
eof = [\u0000];
notspace = any\space;
semicolon = [^\\][;];
*/

#define YYCURSOR        input

YYCTYPE *GrammarParser::re2c_skipline(YYCTYPE *input) {
skipline_start:
/*!re2c
		eof				{goto skipline_end;}
        newline			{result->lines++; goto skipline_end;}
		any				{goto skipline_start;}
*/
skipline_end:
	return YYCURSOR;
}

YYCTYPE *GrammarParser::re2c_parseTagList(YYCTYPE *input, Set *set) {
parseTagList_start:
/*!re2c
		eof				{goto parseTagList_end;}
        newline			{result->lines++; goto parseTagList_start;}
        semicolon		{goto parseTagList_end;}
        notspace+		{set=set;}
        '#'				{YYCURSOR = re2c_skipline(YYCURSOR); goto parseTagList_start;}
		any				{goto parseTagList_start;}
*/

parseTagList_end:
	return YYCURSOR;
}

YYCTYPE *GrammarParser::re2c_parseDelimiters(YYCTYPE *input) {
	CG3::Set *curset = result->allocateSet();
	curset->setName(stringbits[S_DELIMITSET]);
	curset->line = result->lines;

parseDelimiters_start:
/*!re2c
		eof				{goto parseDelimiters_end;}
        newline			{result->lines++; goto parseDelimiters_start;}
        semicolon		{goto parseDelimiters_end;}
        '='				{YYCURSOR = re2c_parseTagList(YYCURSOR, curset); goto parseDelimiters_end;}
        '#'				{YYCURSOR = re2c_skipline(YYCURSOR); goto parseDelimiters_start;}
		any				{goto parseDelimiters_start;}
*/

parseDelimiters_end:
	result->addSet(curset);
	result->delimiters = curset;
	return YYCURSOR;
}

KEYWORDS GrammarParser::re2c_scan(YYCTYPE *input) {
	YYCTYPE *YYMARKER = 0;
	KEYWORDS retval = K_IGNORE;
	
scanstart:
/*!re2c
		eof				{return K_IGNORE;}
        newline			{result->lines++; goto scanstart;}
        'DELIMITERS'	{YYCURSOR = re2c_parseDelimiters(YYCURSOR); goto scanstart;}
        'SETS'			{retval = K_SETS; goto scanend;}
        'SET'			{retval = K_SET; goto scanend;}
        'LIST'			{retval = K_LIST; goto scanend;}
        '#'				{YYCURSOR = re2c_skipline(YYCURSOR); goto scanstart;}
		any				{goto scanstart;}
*/

scanend:
	return retval;
}

int GrammarParser::re2c_grammar_from_ufile(UFILE *input) {
	u_frewind(input);
	if (u_feof(input)) {
		u_fprintf(ux_stderr, "Error: Input is null - nothing to parse!\n");
		return -1;
	}
	if (!result) {
		u_fprintf(ux_stderr, "Error: No preallocated grammar provided - cannot continue!\n");
		return -1;
	}
	
	free_keywords();
	free_regexps();
	free_strings();

	int error = init_keywords();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_keywords returned %u!\n", error);
		return error;
	}

	error = init_regexps();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_regexps returned %u!\n", error);
		return error;
	}

	error = init_strings();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_strings returned %u!\n", error);
		return error;
	}

	UChar *buffer = new UChar[result->grammar_size+8];
	memset(buffer, 0, sizeof(UChar)*(result->grammar_size+8));
	u_file_read(buffer, result->grammar_size, input);
	
	UChar *offset = buffer;
	re2c_scan(offset);
	
	delete buffer;
	free_regexps();
	free_strings();

	return 0;
}
