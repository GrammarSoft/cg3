/* Generated by re2c 0.10.6 on Sun Oct 29 00:23:38 2006 */
/*
 * Copyright (C) 2006, GrammarSoft Aps
 * and the VISL project at the University of Southern Denmark.
 * All Rights Reserved.
 *
 * The contents of this file are subject to the GrammarSoft Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.grammarsoft.com/GSPL or
 * http://visl.sdu.dk/GSPL.txt
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 */

#include "stdafx.h"
#include "Strings.h"
#include <unicode/uregex.h>
#include "GrammarParser.h"
#include "Grammar.h"
#include "uextras.h"
#include <sys/stat.h>

using namespace CG3;
using namespace CG3::Strings;



#define YYCURSOR        input

YYCTYPE *GrammarParser::re2c_skipline(YYCTYPE *input) {
skipline_start:

{
	YYCTYPE yych;

	yych = *YYCURSOR;
	if(yych <= 0x000C) {
		if(yych <= 0x0009) {
			if(yych >= 0x0001) goto yy6;
		} else {
			if(yych == 0x000B) goto yy6;
			goto yy4;
		}
	} else {
		if(yych <= 0x0085) {
			if(yych <= 0x0084) goto yy6;
			goto yy4;
		} else {
			if(yych <= 0x2027) goto yy6;
			if(yych <= 0x2029) goto yy4;
			goto yy6;
		}
	}
	++YYCURSOR;
	{goto skipline_end;}
yy4:
	++YYCURSOR;
	{result->lines++; goto skipline_end;}
yy6:
	++YYCURSOR;
	{goto skipline_start;}
}

skipline_end:
	return YYCURSOR;
}

YYCTYPE *GrammarParser::re2c_parseTagList(YYCTYPE *input, Set *set) {
	marker = YYCURSOR;

parseTagList_start:

{
	YYCTYPE yych;
	yych = *YYCURSOR;
	if(yych <= '"') {
		if(yych <= 0x000B) {
			if(yych <= 0x0008) {
				if(yych >= 0x0001) goto yy16;
			} else {
				if(yych == 0x000A) goto yy12;
				goto yy14;
			}
		} else {
			if(yych <= 0x000D) {
				if(yych <= 0x000C) goto yy12;
				goto yy14;
			} else {
				if(yych <= 0x001B) goto yy16;
				if(yych <= ' ') goto yy14;
				goto yy16;
			}
		}
	} else {
		if(yych <= '\\') {
			if(yych <= ':') {
				if(yych <= '#') goto yy19;
				goto yy16;
			} else {
				if(yych <= ';') goto yy21;
				if(yych <= '[') goto yy16;
				goto yy18;
			}
		} else {
			if(yych <= 0x0085) {
				if(yych <= 0x0084) goto yy16;
				goto yy12;
			} else {
				if(yych <= 0x2027) goto yy16;
				if(yych <= 0x2029) goto yy12;
				goto yy16;
			}
		}
	}
	++YYCURSOR;
	if((yych = *YYCURSOR) <= 0x000D) {
		if(yych <= 0x000A) {
			if(yych != 0x0009) goto yy24;
		} else {
			if(yych == 0x000C) goto yy24;
		}
	} else {
		if(yych <= '"') {
			if(yych <= 0x001B) goto yy24;
			if(yych >= '!') goto yy24;
		} else {
			if(yych <= '#') goto yy11;
			if(yych != ';') goto yy24;
		}
	}
yy11:
	{goto parseTagList_end;}
yy12:
	++YYCURSOR;
	if((yych = *YYCURSOR) <= 0x000D) {
		if(yych <= 0x000A) {
			if(yych != 0x0009) goto yy24;
		} else {
			if(yych == 0x000C) goto yy24;
		}
	} else {
		if(yych <= '"') {
			if(yych <= 0x001B) goto yy24;
			if(yych >= '!') goto yy24;
		} else {
			if(yych <= '#') goto yy13;
			if(yych != ';') goto yy24;
		}
	}
yy13:
	{
		marker = YYCURSOR;
		result->lines++;
		goto parseTagList_start;
		}
yy14:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy28;
yy15:
	{
		marker = YYCURSOR;
		goto parseTagList_start;
		}
yy16:
	++YYCURSOR;
	yych = *YYCURSOR;
	goto yy24;
yy17:
	{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, length-1);
		CG3::CompositeTag *ctag = result->allocateCompositeTag();
		CG3::Tag *tag = result->allocateTag(buffer);
		result->addTagToCompositeTag(tag, ctag);
		result->addCompositeTagToSet(set, ctag);
		delete buffer;
		marker = YYCURSOR;
		goto parseTagList_start;
		}
yy18:
	yych = *++YYCURSOR;
	if(yych == '#') goto yy23;
	if(yych == ';') goto yy23;
	goto yy24;
yy19:
	++YYCURSOR;
	{
		YYCURSOR = re2c_skipline(YYCURSOR);
		marker = YYCURSOR;
		goto parseTagList_start;
		}
yy21:
	++YYCURSOR;
	{goto parseTagList_end;}
yy23:
	++YYCURSOR;
	yych = *YYCURSOR;
yy24:
	if(yych <= 0x001B) {
		if(yych <= 0x000A) {
			if(yych == 0x0009) goto yy17;
			goto yy23;
		} else {
			if(yych == 0x000C) goto yy23;
			if(yych <= 0x000D) goto yy17;
			goto yy23;
		}
	} else {
		if(yych <= ':') {
			if(yych <= ' ') goto yy17;
			if(yych == '#') goto yy17;
			goto yy23;
		} else {
			if(yych <= ';') goto yy17;
			if(yych != '\\') goto yy23;
		}
	}
yy25:
	++YYCURSOR;
	yych = *YYCURSOR;
	if(yych <= 0x000C) {
		if(yych <= 0x0009) {
			if(yych <= 0x0008) goto yy23;
			goto yy17;
		} else {
			if(yych == 0x000B) goto yy17;
			goto yy23;
		}
	} else {
		if(yych <= ' ') {
			if(yych <= 0x000D) goto yy17;
			if(yych <= 0x001B) goto yy23;
			goto yy17;
		} else {
			if(yych == '\\') goto yy25;
			goto yy23;
		}
	}
yy27:
	++YYCURSOR;
	yych = *YYCURSOR;
yy28:
	if(yych <= 0x000B) {
		if(yych == 0x0009) goto yy27;
		if(yych <= 0x000A) goto yy15;
		goto yy27;
	} else {
		if(yych <= 0x000D) {
			if(yych <= 0x000C) goto yy15;
			goto yy27;
		} else {
			if(yych <= 0x001B) goto yy15;
			if(yych <= ' ') goto yy27;
			goto yy15;
		}
	}
}


parseTagList_end:
	return YYCURSOR;
}

YYCTYPE *GrammarParser::re2c_parseDelimiters(YYCTYPE *input) {
	CG3::Set *curset = result->allocateSet();
	curset->setName(stringbits[S_DELIMITSET]);
	curset->line = result->lines;

parseDelimiters_start:

{
	YYCTYPE yych;
	yych = *YYCURSOR;
	if(yych <= ':') {
		if(yych <= 0x000B) {
			if(yych <= 0x0000) goto yy31;
			if(yych == 0x000A) goto yy33;
			goto yy41;
		} else {
			if(yych <= 0x000C) goto yy33;
			if(yych == '#') goto yy37;
			goto yy41;
		}
	} else {
		if(yych <= 0x0084) {
			if(yych <= ';') goto yy39;
			if(yych == '=') goto yy35;
			goto yy41;
		} else {
			if(yych <= 0x0085) goto yy33;
			if(yych <= 0x2027) goto yy41;
			if(yych <= 0x2029) goto yy33;
			goto yy41;
		}
	}
yy31:
	++YYCURSOR;
	{goto parseDelimiters_end;}
yy33:
	++YYCURSOR;
	{result->lines++; goto parseDelimiters_start;}
yy35:
	++YYCURSOR;
	{YYCURSOR = re2c_parseTagList(YYCURSOR, curset); goto parseDelimiters_end;}
yy37:
	++YYCURSOR;
	{YYCURSOR = re2c_skipline(YYCURSOR); goto parseDelimiters_start;}
yy39:
	++YYCURSOR;
	{goto parseDelimiters_end;}
yy41:
	++YYCURSOR;
	{goto parseDelimiters_start;}
}


parseDelimiters_end:
	result->addSet(curset);
	result->delimiters = curset;
	return YYCURSOR;
}

KEYWORDS GrammarParser::re2c_scan(YYCTYPE *input) {
	KEYWORDS retval = K_IGNORE;
	YYCTYPE *YYMARKER = 0;
	
scan_start:

{
	YYCTYPE yych;
	yych = *YYCURSOR;
	if(yych <= 'R') {
		if(yych <= '"') {
			if(yych <= 0x000A) {
				if(yych <= 0x0000) goto yy45;
				if(yych <= 0x0009) goto yy56;
				goto yy47;
			} else {
				if(yych == 0x000C) goto yy47;
				goto yy56;
			}
		} else {
			if(yych <= 'D') {
				if(yych <= '#') goto yy54;
				if(yych <= 'C') goto yy56;
				goto yy49;
			} else {
				if(yych <= 'E') goto yy53;
				if(yych == 'L') goto yy52;
				goto yy56;
			}
		}
	} else {
		if(yych <= 'l') {
			if(yych <= 'd') {
				if(yych <= 'S') goto yy51;
				if(yych <= 'c') goto yy56;
				goto yy49;
			} else {
				if(yych <= 'e') goto yy53;
				if(yych <= 'k') goto yy56;
				goto yy52;
			}
		} else {
			if(yych <= 0x0084) {
				if(yych == 's') goto yy51;
				goto yy56;
			} else {
				if(yych <= 0x0085) goto yy47;
				if(yych <= 0x2027) goto yy56;
				if(yych <= 0x2029) goto yy47;
				goto yy56;
			}
		}
	}
yy45:
	++YYCURSOR;
	{return K_IGNORE;}
yy47:
	++YYCURSOR;
	{result->lines++; goto scan_start;}
yy49:
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 'E') goto yy70;
	if(yych == 'e') goto yy70;
yy50:
	{goto scan_start;}
yy51:
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 'E') goto yy65;
	if(yych == 'e') goto yy65;
	goto yy50;
yy52:
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 'I') goto yy61;
	if(yych == 'i') goto yy61;
	goto yy50;
yy53:
	yych = *(YYMARKER = ++YYCURSOR);
	if(yych == 'N') goto yy57;
	if(yych == 'n') goto yy57;
	goto yy50;
yy54:
	++YYCURSOR;
	{YYCURSOR = re2c_skipline(YYCURSOR); goto scan_start;}
yy56:
	yych = *++YYCURSOR;
	goto yy50;
yy57:
	yych = *++YYCURSOR;
	if(yych == 'D') goto yy59;
	if(yych == 'd') goto yy59;
yy58:
	YYCURSOR = YYMARKER;
	goto yy50;
yy59:
	++YYCURSOR;
	{return K_IGNORE;}
yy61:
	yych = *++YYCURSOR;
	if(yych == 'S') goto yy62;
	if(yych != 's') goto yy58;
yy62:
	yych = *++YYCURSOR;
	if(yych == 'T') goto yy63;
	if(yych != 't') goto yy58;
yy63:
	++YYCURSOR;
	{retval = K_LIST; goto scan_end;}
yy65:
	yych = *++YYCURSOR;
	if(yych == 'T') goto yy66;
	if(yych != 't') goto yy58;
yy66:
	++YYCURSOR;
	if((yych = *YYCURSOR) == 'S') goto yy68;
	if(yych == 's') goto yy68;
	{retval = K_SET; goto scan_end;}
yy68:
	++YYCURSOR;
	{goto scan_start;}
yy70:
	yych = *++YYCURSOR;
	if(yych == 'L') goto yy71;
	if(yych != 'l') goto yy58;
yy71:
	yych = *++YYCURSOR;
	if(yych == 'I') goto yy72;
	if(yych != 'i') goto yy58;
yy72:
	yych = *++YYCURSOR;
	if(yych == 'M') goto yy73;
	if(yych != 'm') goto yy58;
yy73:
	yych = *++YYCURSOR;
	if(yych == 'I') goto yy74;
	if(yych != 'i') goto yy58;
yy74:
	yych = *++YYCURSOR;
	if(yych == 'T') goto yy75;
	if(yych != 't') goto yy58;
yy75:
	yych = *++YYCURSOR;
	if(yych == 'E') goto yy76;
	if(yych != 'e') goto yy58;
yy76:
	yych = *++YYCURSOR;
	if(yych == 'R') goto yy77;
	if(yych != 'r') goto yy58;
yy77:
	yych = *++YYCURSOR;
	if(yych == 'S') goto yy78;
	if(yych != 's') goto yy58;
yy78:
	++YYCURSOR;
	{YYCURSOR = re2c_parseDelimiters(YYCURSOR); goto scan_start;}
}


scan_end:
	return retval;
}

int GrammarParser::re2c_grammar_from_ufile(UFILE *input) {
	u_frewind(input);
	if (u_feof(input)) {
		u_fprintf(ux_stderr, "Error: Input is null - nothing to parse!\n");
		return -1;
	}
	if (!result) {
		u_fprintf(ux_stderr, "Error: No preallocated grammar provided - cannot continue!\n");
		return -1;
	}
	
	free_keywords();
	free_regexps();
	free_strings();

	int error = init_keywords();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_keywords returned %u!\n", error);
		return error;
	}

	error = init_regexps();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_regexps returned %u!\n", error);
		return error;
	}

	error = init_strings();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_strings returned %u!\n", error);
		return error;
	}

	UChar *buffer = new UChar[result->grammar_size+8];
	memset(buffer, 0, sizeof(UChar)*(result->grammar_size+8));
	u_file_read(buffer, result->grammar_size, input);
	
	UChar *offset = buffer;
	re2c_scan(offset);
	
	delete buffer;
	free_regexps();
	free_strings();

	return 0;
}
