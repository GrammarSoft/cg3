/*
 * Copyright (C) 2006, GrammarSoft Aps
 * and the VISL project at the University of Southern Denmark.
 * All Rights Reserved.
 *
 * The contents of this file are subject to the GrammarSoft Public
 * License Version 1.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.grammarsoft.com/GSPL or
 * http://visl.sdu.dk/GSPL.txt
 * 
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 */

#include "GPRE2C.h"

// This disables the warnings for \uXXXX style characters.
#ifdef WIN32
	#pragma warning( disable : 4428 4566 )
#endif

using namespace CG3;
using namespace CG3::Strings;
#define YYCURSOR        input
#define __WHITESPACE	"%[^ \t\x0A\x0B\x0C\x0D\u001C\u001D\u001E\u001F\u2028\u2029\x85]"

/*!re2c
	re2c:yyfill:enable = 0 ;

	newline = [\n\u2028\u2029\x85\x0C];
	space = [ \t\r\x0B\x0D\u001C\u001D\u001E\u001F];
	any = [^]\newline;
	eof = [\u0000];
	special = [#;)(];
	notspecial = [^#;)(]\(space|newline);
	escaped = [\\] special;
	entity = (notspecial|escaped);
	setname = (notspecial|escaped|[#]);
	setop = ("|"|"+"|"-"|'OR'|"*"|"^"|"!");
*/

YYCTYPE *GPRE2C::skipline(YYCTYPE *input) {
skipline_start:
/*!re2c
	eof				{goto skipline_end;}
	newline			{result->lines++; goto skipline_end;}
	any				{goto skipline_start;}
*/
skipline_end:
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseCompositeTag(YYCTYPE *input, Set *set) {
	CG3::CompositeTag *ctag = result->allocateCompositeTag();
	marker = YYCURSOR;

parseCompositeTag_start:
/*!re2c
	eof				{goto parseCompositeTag_end;}
	newline			{
		marker = YYCURSOR;
		result->lines++;
		goto parseCompositeTag_start;
		}
	entity+			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		CG3::Tag *tag = result->allocateTag(buffer);
		result->addTagToCompositeTag(tag, ctag);
		delete buffer;
		marker = YYCURSOR;
		goto parseCompositeTag_start;
		}
	"#"				{
		YYCURSOR = skipline(YYCURSOR);
		marker = YYCURSOR;
		goto parseCompositeTag_start;
		}
	"("				{u_fprintf(ux_stderr, "Error: Mismatched ( on line %u!\n", result->lines); exit(1);}
	")"				{goto parseCompositeTag_end;}
	";"				{u_fprintf(ux_stderr, "Error: Found ; before ) on line %u!\n", result->lines); exit(1);}
	any				{
		marker = YYCURSOR;
		goto parseCompositeTag_start;
		}
*/

parseCompositeTag_end:
	if (ctag->tags_map.empty()) {
		u_fprintf(ux_stderr, "Error: Empty () on line %u!\n", result->lines);
		exit(1);
	}
	result->addCompositeTagToSet(set, ctag);
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseInlineSet(YYCTYPE *input, Set **ret_set) {
	CG3::Set *curset = result->allocateSet();
	curset->line = result->lines;
	curset->setName((uint32_t)0);
	CG3::CompositeTag *ctag = result->allocateCompositeTag();
	marker = YYCURSOR;

parseInlineSet_start:
/*!re2c
	eof				{goto parseInlineSet_end;}
	newline			{marker = YYCURSOR; result->lines++; goto parseInlineSet_start;}
	entity+			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		CG3::Tag *tag = result->allocateTag(buffer);
		result->addTagToCompositeTag(tag, ctag);
		delete buffer;
		marker = YYCURSOR;
		goto parseInlineSet_start;
		}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto parseInlineSet_start;}
	"("				{u_fprintf(ux_stderr, "Error: Mismatched ( on line %u!\n", result->lines); exit(1);}
	")"				{goto parseInlineSet_end;}
	";"				{u_fprintf(ux_stderr, "Error: Found ; before ) on line %u!\n", result->lines); exit(1);}
	any				{
		marker = YYCURSOR;
		goto parseInlineSet_start;
		}
*/

parseInlineSet_end:
	result->addCompositeTagToSet(curset, ctag);
	result->addSet(curset);
	*ret_set = curset;
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseSetList(YYCTYPE *input, Set *set) {
	bool want_set = true;
	marker = YYCURSOR;

parseSetList_start:
/*!re2c
	eof				{goto parseSetList_end;}
	newline			{marker = YYCURSOR; result->lines++; goto parseSetList_start;}
	setop			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		if (want_set) {
			u_fprintf(ux_stderr, "Error: Missing set for operator %S on line %u!\n", buffer, result->lines);
			exit(1);
		}
		uint32_t set_op = ux_isSetOp(buffer);
		set->set_ops.push_back(set_op);
		want_set = true;
		marker = YYCURSOR;
		goto parseSetList_start;
		}
	setname+		{
		if (!want_set) {
			return YYCURSOR;
		}
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		uint32_t set_hash = hash_sdbm_uchar(buffer, 0);
		if (result->set_alias.find(set_hash) != result->set_alias.end()) {
			set_hash = result->set_alias[set_hash];
		}
		set_hash = result->getSet(set_hash)->hash;
		set->sets.push_back(set_hash);
		delete buffer;
		marker = YYCURSOR;
		want_set = false;
		goto parseSetList_start;
		}
	"("				{
		if (!want_set) {
			return YYCURSOR;
		}
		Set *ret_set = 0;
		YYCURSOR = parseInlineSet(YYCURSOR, &ret_set);
		uint32_t set_hash = ret_set->hash;
		if (result->set_alias.find(set_hash) != result->set_alias.end()) {
			set_hash = result->set_alias[set_hash];
		}
		set->sets.push_back(set_hash);
		marker = YYCURSOR;
		want_set = false;
		goto parseSetList_start;
		}
	")"				{u_fprintf(ux_stderr, "Error: Mismatched ) on line %u!\n", result->lines); exit(1);}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto parseSetList_start;}
	space			{marker = YYCURSOR; goto parseSetList_start;}
	";"				{goto parseSetList_end;}
	any				{goto parseSetList_end;}
*/

parseSetList_end:
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseTagList(YYCTYPE *input, Set *set) {
	marker = YYCURSOR;

parseTagList_start:
/*!re2c
	eof				{goto parseTagList_end;}
	newline			{
		marker = YYCURSOR;
		result->lines++;
		goto parseTagList_start;
		}
	entity+			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		CG3::CompositeTag *ctag = result->allocateCompositeTag();
		CG3::Tag *tag = result->allocateTag(buffer);
		result->addTagToCompositeTag(tag, ctag);
		result->addCompositeTagToSet(set, ctag);
		delete buffer;
		marker = YYCURSOR;
		goto parseTagList_start;
		}
	"("				{
		YYCURSOR = parseCompositeTag(YYCURSOR, set);
		marker = YYCURSOR;
		goto parseTagList_start;
		}
	")"				{u_fprintf(ux_stderr, "Error: Mismatched ) on line %u!\n", result->lines); exit(1);}
	"#"				{
		YYCURSOR = skipline(YYCURSOR);
		marker = YYCURSOR;
		goto parseTagList_start;
		}
	";"				{goto parseTagList_end;}
	any				{
		marker = YYCURSOR;
		goto parseTagList_start;
		}
*/

parseTagList_end:
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseMappingList(YYCTYPE *input, std::list<uint32_t> *taglist) {
	marker = YYCURSOR;

parseMappingList_start:
/*!re2c
	eof				{goto parseMappingList_end;}
	newline			{
		marker = YYCURSOR;
		result->lines++;
		goto parseMappingList_start;
		}
	entity+			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		CG3::Tag *tag = result->allocateTag(buffer);
		tag->parseTag(buffer);
		tag->rehash();
		result->addTag(tag);
		taglist->push_back(tag->hash);
		delete buffer;
		marker = YYCURSOR;
		goto parseMappingList_start;
		}
	")"				{goto parseMappingList_end;}
	"#"				{
		YYCURSOR = skipline(YYCURSOR);
		marker = YYCURSOR;
		goto parseMappingList_start;
		}
	";"				{goto parseMappingList_end;}
	any				{
		marker = YYCURSOR;
		goto parseMappingList_start;
		}
*/

parseMappingList_end:
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseDelimiters(YYCTYPE *input, STRINGS which) {
	CG3::Set *curset = result->allocateSet();
	curset->setName(stringbits[which]);
	curset->line = result->lines;

parseDelimiters_start:
/*!re2c
	eof				{goto parseDelimiters_end;}
	newline			{result->lines++; goto parseDelimiters_start;}
	"="				{YYCURSOR = parseTagList(YYCURSOR, curset); goto parseDelimiters_end;}
	"#"				{YYCURSOR = skipline(YYCURSOR); goto parseDelimiters_start;}
	";"				{goto parseDelimiters_end;}
	any				{goto parseDelimiters_start;}
*/

parseDelimiters_end:
	result->addSet(curset);
	if (which == S_DELIMITSET) {
		result->delimiters = curset;
	}
	else if (which == S_SOFTDELIMITSET) {
		result->soft_delimiters = curset;
	}
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseMapAddReplaceAppend(YYCTYPE *input, KEYWORDS which) {
	CG3::Rule *rule = result->allocateRule();
	rule->line = result->lines;
	rule->type = which;

	UChar wform[256];
	if (marker[0] == '"' && marker[1] == '<') {
		u_sscanf(marker, __WHITESPACE, &wform);
	}
	else if (last_entity[0] == '"' && last_entity[1] == '<') {
		u_sscanf(last_entity, __WHITESPACE, &wform);
	}
	if (wform[0] == '"' && wform[1] == '<' && u_strlen(wform) < 256 && wform[u_strlen(wform)] == 0) {
		Tag *wformt = result->allocateTag(wform);
		rule->wordform = wformt->rehash();
		result->addTag(wformt);
	}

parseMapAddReplaceAppend_start:
/*!re2c
	eof				{goto parseMapAddReplaceAppend_end;}
	newline			{result->lines++; goto parseMapAddReplaceAppend_start;}
	"#"				{YYCURSOR = skipline(YYCURSOR); goto parseMapAddReplaceAppend_start;}
	"("				{
			if (rule->maplist.empty()) {
				YYCURSOR = parseMappingList(YYCURSOR, &rule->maplist);
			}
		}
	";"				{goto parseMapAddReplaceAppend_end;}
	any				{goto parseMapAddReplaceAppend_start;}
*/

parseMapAddReplaceAppend_end:
	if (rule->maplist.empty()) {
		u_fprintf(ux_stderr, "Error: Mapping-type rule on line %u had no list of tags to work with!\n", result->lines);
		exit(0);
	}

	uint32_t rset = 0;
	CG3::Set *curset = result->allocateSet();
	curset->line = result->lines;
	// ToDo: Generate a unique set name somehow faster.
	curset->setName(hash_sdbm_uchar(input, result->lines+which));
	YYCURSOR = parseSetList(YYCURSOR, curset);
	if (curset->sets.size() == 1) {
		rset = curset->sets.at(0);
		result->destroySet(curset);
		curset = result->getSet(rset);
	}
	else {
		rset = curset->rehash();
	}
	rule->target = rset;
	result->addSet(curset);

	addRuleToGrammar(rule);
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseMappingPrefix(YYCTYPE *input) {
parseMappingPrefix_start:
/*!re2c
	eof				{goto parseMappingPrefix_end;}
	newline			{result->lines++; goto parseMappingPrefix_start;}
	"="				{marker = YYCURSOR; goto parseMappingPrefix_middle;}
	"#"				{YYCURSOR = skipline(YYCURSOR); goto parseMappingPrefix_start;}
	";"				{goto parseMappingPrefix_end;}
	any				{goto parseMappingPrefix_start;}
*/

parseMappingPrefix_middle:
/*!re2c
	eof				{goto parseMappingPrefix_end;}
	newline			{result->lines++; marker = YYCURSOR; goto parseMappingPrefix_middle;}
	entity+			{result->mapping_prefix = marker[0]; goto parseMappingPrefix_middle;}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto parseMappingPrefix_middle;}
	";"				{goto parseMappingPrefix_end;}
	any				{marker = YYCURSOR; goto parseMappingPrefix_middle;}
*/
parseMappingPrefix_end:
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseList(YYCTYPE *input) {
	marker = YYCURSOR;
	CG3::Set *curset = result->allocateSet();
	curset->line = result->lines;

parseList_start:
/*!re2c
	eof				{goto parseList_end;}
	newline			{marker = YYCURSOR; result->lines++; goto parseList_start;}
	"="				{YYCURSOR = parseTagList(YYCURSOR, curset); marker = YYCURSOR; goto parseList_end;}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto parseList_start;}
	setname+		{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		curset->setName(buffer);
		delete buffer;
		marker = YYCURSOR;
		goto parseList_start;
		}
	";"				{goto parseList_end;}
	any				{marker = YYCURSOR; goto parseList_start;}
*/

parseList_end:
	result->addSet(curset);
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parseSet(YYCTYPE *input) {
	marker = YYCURSOR;
	CG3::Set *curset = result->allocateSet();
	curset->line = result->lines;
	if (result->lines == 1333) {
		input=input;
	}

parseSet_start:
/*!re2c
	eof				{goto parseSet_end;}
	newline			{marker = YYCURSOR; result->lines++; goto parseSet_start;}
	"="				{YYCURSOR = parseSetList(YYCURSOR, curset); marker = YYCURSOR; goto parseSet_end;}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto parseSet_start;}
	setname+		{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		curset->setName(buffer);
		delete buffer;
		marker = YYCURSOR;
		goto parseSet_start;
		}
	";"				{goto parseSet_end;}
	any				{marker = YYCURSOR; goto parseSet_start;}
*/

parseSet_end:
	if (curset->sets.size() == 1) {
		uint32_t res = curset->sets.at(0);
		result->set_alias[hash_sdbm_uchar(curset->name, 0)] = res;
		result->destroySet(curset);
		curset = result->getSet(res);
	}
	result->addSet(curset);
	return YYCURSOR;
}

YYCTYPE *GPRE2C::parsePreferredTargets(YYCTYPE *input) {
	marker = YYCURSOR;

parsePreferredTargets_start:
/*!re2c
	eof				{goto parsePreferredTargets_end;}
	newline			{
		marker = YYCURSOR;
		result->lines++;
		goto parsePreferredTargets_start;
		}
	entity+			{
		size_t length = (YYCURSOR - marker)+1;
		YYCTYPE *buffer = new YYCTYPE[length];
		buffer[length-1] = 0;
		u_strncpy(buffer, marker, (int32_t)length-1);
		if (!(buffer[0] == '=' && u_strlen(buffer) == 1)) {
			result->addPreferredTarget(buffer);
		}
		delete buffer;
		marker = YYCURSOR;
		goto parsePreferredTargets_start;
		}
	"("				{u_fprintf(ux_stderr, "Error: Unexpected ( on line %u!\n", result->lines); exit(1);}
	")"				{u_fprintf(ux_stderr, "Error: Unexpected ) on line %u!\n", result->lines); exit(1);}
	"#"				{
		YYCURSOR = skipline(YYCURSOR);
		marker = YYCURSOR;
		goto parsePreferredTargets_start;
		}
	";"				{goto parsePreferredTargets_end;}
	any				{
		marker = YYCURSOR;
		goto parsePreferredTargets_start;
		}
*/

parsePreferredTargets_end:
	if (result->preferred_targets.empty()) {
		u_fprintf(ux_stderr, "Warning: PREFERRED-TARGETS was declared with no elements on line %u.\n", result->lines);
	}
	return YYCURSOR;
}

KEYWORDS GPRE2C::scan(YYCTYPE *input) {
	KEYWORDS retval = K_IGNORE;
	YYCTYPE *YYMARKER = 0;
	YYMARKER = YYMARKER; // Just to foil the warning. Compiler will optimize this away.
	marker = YYCURSOR;
	
scan_start:
/*!re2c
	eof				{retval = K_IGNORE; goto scan_end;}
	newline			{marker = YYCURSOR; result->lines++; goto scan_start;}
	space			{goto scan_start;}
	'PREFERRED-TARGETS'		{YYCURSOR = parsePreferredTargets(YYCURSOR); marker = YYCURSOR; goto scan_start;}
	'BEFORE-SECTIONS'		{in_before_sections = true; in_section = in_after_sections = false; goto scan_start;}
	'SOFT-DELIMITERS'		{YYCURSOR = parseDelimiters(YYCURSOR, S_SOFTDELIMITSET); marker = YYCURSOR; goto scan_start;}
	'AFTER-SECTIONS'		{in_after_sections = true; in_section = in_before_sections = false; goto scan_start;}
	'MAPPING-PREFIX'		{YYCURSOR = parseMappingPrefix(YYCURSOR); marker = YYCURSOR; goto scan_start;}
	'REMVARIABLE'	{goto scan_start;}
	'SETVARIABLE'	{goto scan_start;}
	'CORRECTIONS'	{in_before_sections = true; in_section = in_after_sections = false; goto scan_start;}
	'CONSTRAINTS'	{in_section = true; in_before_sections = in_after_sections = false; goto scan_start;}
	'DELIMITERS'	{YYCURSOR = parseDelimiters(YYCURSOR, S_DELIMITSET); marker = YYCURSOR; goto scan_start;}
	'SUBSTITUTE'	{goto scan_start;}
	'MAPPINGS'		{in_before_sections = true; in_section = in_after_sections = false; goto scan_start;}
	'SECTION'		{in_section = true; in_before_sections = in_after_sections = false; goto scan_start;}
	'EXECUTE'		{goto scan_start;}
	'DELIMIT'		{goto scan_start;}
	'REPLACE'		{goto scan_start;}
	'SELECT'		{goto scan_start;}
	'REMOVE'		{goto scan_start;}
	'ANCHOR'		{goto scan_start;}
	'APPEND'		{goto scan_start;}
	'ABORT'			{goto scan_start;}
	'MATCH'			{goto scan_start;}
	'JUMP'			{goto scan_start;}
	'SETS'			{goto scan_start;}
	'LIST'			{YYCURSOR = parseList(YYCURSOR); marker = YYCURSOR; goto scan_start;}
	'SET'			{YYCURSOR = parseSet(YYCURSOR); marker = YYCURSOR; goto scan_start;}
	'IFF'			{goto scan_start;}
	'MAP'			{YYCURSOR = parseMapAddReplaceAppend(YYCURSOR, K_MAP); marker = YYCURSOR; goto scan_start;}
	'ADD'			{goto scan_start;}
	'END'			{retval = K_IGNORE; goto scan_end;}
	"#"				{YYCURSOR = skipline(YYCURSOR); marker = YYCURSOR; goto scan_start;}
	entity+			{last_entity = YYCURSOR; goto scan_start;}
	any				{u_fprintf(ux_stderr, "Error: Unexpected input on line %u!\n", result->lines); goto scan_end;}
*/

scan_end:
	marker = 0;
	return retval;
}

GPRE2C::GPRE2C() {
	filename = 0;
	locale = 0;
	codepage = 0;
	result = 0;
	option_vislcg_compat = false;
	in_before_sections = false;
	in_after_sections = false;
	in_section = false;
	marker = 0;
	last_entity = 0;
}

GPRE2C::~GPRE2C() {
	filename = 0;
	locale = 0;
	codepage = 0;
	result = 0;
}

void GPRE2C::setResult(CG3::Grammar *res) {
	result = res;
}

void GPRE2C::setCompatible(bool f) {
	option_vislcg_compat = f;
}

void GPRE2C::addRuleToGrammar(Rule *rule) {
	if (in_section) {
		result->addRule(rule, &result->rules);
	}
	else if (in_before_sections) {
		result->addRule(rule, &result->before_sections);
	}
	else if (in_after_sections) {
		result->addRule(rule, &result->after_sections);
	}
}

int GPRE2C::grammar_from_ufile(UFILE *input) {
	u_frewind(input);
	if (u_feof(input)) {
		u_fprintf(ux_stderr, "Error: Input is null - nothing to parse!\n");
		return -1;
	}
	if (!result) {
		u_fprintf(ux_stderr, "Error: No preallocated grammar provided - cannot continue!\n");
		return -1;
	}
	
	free_keywords();
	free_regexps();
	free_strings();

	int error = init_keywords();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_keywords returned %i!\n", error);
		return error;
	}

	error = init_regexps();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_regexps returned %i!\n", error);
		return error;
	}

	error = init_strings();
	if (error) {
		u_fprintf(ux_stderr, "Error: init_strings returned %i!\n", error);
		return error;
	}

	UChar *buffer = new UChar[result->grammar_size+8];
	memset(buffer, 0, sizeof(UChar)*(result->grammar_size+8));
	u_file_read(buffer, result->grammar_size, input);
	
	UChar *offset = buffer;
	if (u_strlen(offset) > 0) {
		result->lines = 1;
		scan(offset);
	} else {
		u_fprintf(ux_stderr, "Error: Grammar file is empty - nothing to parse!\n");
		return -1;
	}
	
	delete buffer;
	free_regexps();
	free_strings();

	return 0;
}

int GPRE2C::parse_grammar_from_file(const char *fname, const char *loc, const char *cpage) {
	filename = fname;
	locale = loc;
	codepage = cpage;

	if (!result) {
		u_fprintf(ux_stderr, "Error: Cannot parse into nothing - hint: call setResult() before trying.\n");
		return -1;
	}

	struct stat _stat;
	int error = stat(filename, &_stat);

	if (error != 0) {
		u_fprintf(ux_stderr, "Error: Cannot stat %s due to error %d - bailing out!\n", filename, error);
		exit(1);
	} else {
		result->last_modified = (uint32_t)_stat.st_mtime;
		result->grammar_size = (uint32_t)_stat.st_size;
	}

	result->setName(filename);

	UFILE *grammar = u_fopen(filename, "r", locale, codepage);
	if (!grammar) {
		u_fprintf(ux_stderr, "Error: Error opening %s for reading!\n", filename);
		return -1;
	}
	
	error = grammar_from_ufile(grammar);
	if (error) {
		return error;
	}
	return 0;
}
