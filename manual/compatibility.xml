<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter SYSTEM "docbook-dtd-45/docbookx.dtd">

<chapter id="compatibility">
  <title>Compatibility and Incompatibilities</title>

  <para>
    Things to be aware of.
  </para>

  <section id="gotchas">
    <title>Gotcha's</title>

    <section id="gotcha-magic-readings">
      <title>Magic Readings</title>
      <para>
        In CG-3 all cohorts have at least one reading. If none are given in the input, one is generated
        from the wordform. These magic readings can be the target of rules, which may not always be intended.
      </para>
      <para>
        For example, given the input
        <screen>
          "&lt;word&gt;"
          &nbsp; "word" N NOM SG
          "&lt;$.&gt;"
        </screen>
        a magic reading is made so the cohorts internally looks like
        <screen>
          "&lt;word&gt;"
          &nbsp; "word" N NOM SG
          "&lt;$.&gt;"
          &nbsp; "&lt;$.&gt;" &lt;&lt;&lt;
        </screen>
      </para>
      <para>
        The above input combined with a rule a'la
        <screen>
          MAP (@X) (*) ;
        </screen>
        will give the output
        <screen>
          "&lt;word&gt;"
          &nbsp; "word" N NOM SG @X
          "&lt;$.&gt;"
          &nbsp; "&lt;$.&gt;" @X
        </screen>
        because MAP promoted the last magic reading to a real reading.
      </para>
      <para>
        If you do not want these magic readings to be the possible target of rules, you can use the
        cmdline option --no-magic-readings. Internally they will still be generated and contextual tests
        can still reference them, but rules cannot touch or modify them directly.
        <emphasis>
          <link linkend="keyword-setchild">SETCHILD</link> is an exception.
        </emphasis>
      </para>
    </section>

    <section id="gotcha-not-negate">
      <title>NOT and NEGATE</title>
      <para>
        In CG-2 and VISLCG the keyword NOT behaved differently depending on whether it was
        in front of the first test or in front of a linked test. In the case of
        <screen>
          (NOT 1 LSet LINK 1 KSet LINK 1 JSet)
        </screen>
        the NOT would apply last, meaning it would invert the result of the entire chain,
        but in the case of
        <screen>
          (1 LSet LINK NOT 1 KSet LINK 1 JSet)
        </screen>
        it only inverts the result of the immediately following test.
      </para>

      <para>
        CG-3 implements the <link linkend="test-negate">NEGATE</link> keyword to make the distinction clearer.
        This means that if you are converting grammars to CG-3 you must replace starting NOTs with NEGATEs
        to get the same functionality. So the first test should instead be
        <screen>
          (NEGATE 1 LSet LINK 1 KSet LINK 1 JSet)
        </screen>
      </para>
    </section>

    <section id="gotcha-setop-minus">
      <title>Set Operator -</title>
      <para>
        In CG-2 the - operator means set difference; in VISLCG it means set fail-fast; in CG-3 it means
        set difference again, but the new operator ^ takes place of VISLCG's behavior.
      </para>
    </section>

    <section id="gotcha-first-last-tags">
      <title>&gt;&gt;&gt; and &lt;&lt;&lt;</title>
      <para>
        In VISLCG the magic tags &gt;&gt;&gt; and &lt;&lt;&lt;,
        denoting sentence start and end respectively, could sometimes wind up in the output.
        In CG-3 they are never part of the output.
      </para>
    </section>

    <section id="gotcha-application-order">
      <title>Rule Application Order</title>
      <para>
        In CG-2 the order in which rules are applied on cohorts cannot be reliably predicted.
      </para>
      <para>
        In VISLCG rules can be forced to be applied in the order they occur in the grammar, but
        VISLCG will try to run all rules on the current cohort before trying next cohort:
        <screen>
          ForEach (Window)
          &nbsp; ForEach (Cohort)
          &nbsp;&nbsp; ForEach (Rule)
          &nbsp;&nbsp;&nbsp; ApplyRule
        </screen>
      </para>
      <para>
        CG-3 always applies rules in the order they occur in the grammar, and will try the current
        rule on all cohorts in the window before moving on to the next rule.
        This yields a far more predictable result and cuts down on the need for many sections in the grammar.
        <screen>
          ForEach (Window)
          &nbsp; ForEach (Rule)
          &nbsp;&nbsp; ForEach (Cohort)
          &nbsp;&nbsp;&nbsp; ApplyRule
        </screen>
      </para>
    </section>
  </section>

  <section id="incompatibilites">
    <title>Incompatibilites</title>

    <section id="incompat-mapping">
      <title>Mappings</title>
      <para>
        The CG-2 spec says that readings in the format
        <screen>
          "word" tag @MAP @MUP ntag @MIP
        </screen>
        should be equivalent to
        <screen>
          "word" tag @MAP
          "word" tag @MUP
          "word" tag ntag @MIP
        </screen>
      </para>

      <para>
        Since the tag order does not matter in CG-3, this is instead equivalent to
        <screen>
          "word" tag ntag @MAP
          "word" tag ntag @MUP
          "word" tag ntag @MIP
        </screen>
      </para>
    </section>
  </section>

</chapter>
