<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter SYSTEM "docbook-dtd-45/docbookx.dtd">

<chapter id="contexts">
  <title>Contextual Tests</title>

  <section id="test-position">
    <title>Position Element Order</title>
    <para>
      CG-3 is not very strict with how a contextual position looks. Elements such as ** and C can be
      anywhere before or after the offset number, and even the - for negative offsets does not have
      to be near the number.
    </para>
    <para>
      Examples of valid positions:
      <screen>
        *-1
        1**-
        W*2C
        0**&gt;
        cC
        CsW
      </screen>
    </para>
  </section>

  <section id="test-negate">
    <title>NEGATE</title>
    <indexterm>
      <primary>NEGATE</primary>
    </indexterm>
    <para>
      NEGATE is similar to, yet not the same as, NOT. Where NOT will invert the result of only the
      immediately following test, NEGATE will invert the result of the entire LINK'ed chain that follows.
      NEGATE is thus usually used at the beginning of a test.
      <emphasis>
        VISLCG emulated the NEGATE functionality for tests that started with NOT.
      </emphasis>
    </para>
  </section>

  <section id="test-cbarrier">
    <title>CBARRIER</title>
    <indexterm>
      <primary>CBARRIER</primary>
    </indexterm>
    <para>
      Like <link linkend="keyword-barrier">BARRIER</link> but performs the test in Careful mode,
      meaning it only blocks if all readings in the cohort matches.
      This makes it less strict than <link linkend="keyword-barrier">BARRIER</link>.
    </para>
    <screen>
      (**1 SetG CBARRIER (Verb))
    </screen>
  </section>

  <section id="test-spanning">
    <title>Spanning Window Boundaries</title>
    <indexterm>
      <primary>W</primary>
    </indexterm>
    <indexterm>
      <primary>&lt;</primary>
    </indexterm>
    <indexterm>
      <primary>&gt;</primary>
    </indexterm>
    <para>
      These options allows a test to find matching cohorts in any window currently in the buffer.
      The buffer size can be adjusted with the --num-windows cmdline flag and defaults to 2.
      Meaning, 2 windows on either side of the current one is preserved, so a total of 5 would be in
      the buffer at any time.
    </para>

    <section id="test-span-both">
      <title>Span Both</title>
      <para>
        Allowing a test to span beyond boundaries in either direction is denoted by 'W'.
        One could also allow all tests to behave in this manner with the --always-span cmdline flag.
      </para>
      <screen>
        (-1*W (someset))
      </screen>
    </section>

    <section id="test-span-left">
      <title>Span Left</title>
      <para>
        '&lt;' allows a test to span beyond boundaries in left direction only.
      </para>
      <screen>
        (-3**&lt; (someset))
      </screen>
    </section>

    <section id="test-span-right">
      <title>Span Right</title>
      <para>
        '&gt;' allows a test to span beyond boundaries in right direction only.
      </para>
      <screen>
        (2*&gt; (someset))
      </screen>
    </section>
  </section>

  <section id="test-mark">
    <title>X Marks the Spot</title>
    <indexterm>
      <primary>X</primary>
    </indexterm>
    <indexterm>
      <primary>x</primary>
    </indexterm>
    <para>
	  By default, linked tests continue from the immediately preceding test.
      These options affect behavior.
    </para>

    <screen>
      # Look right for (third), then from there look right for (seventh),
      # then jump back to (target) and from there look right for (fifth)
      SELECT (target) (1* (third) LINK 1* (seventh) LINK 1*x (fifth)) ;

      # Look right for (fourth), then from there look right for (seventh) and set that as the mark,
      # then from there look left for (fifth), then jump back to (seventh) and from there look left for (sixth)
      SELECT (target) (1* (fourth) LINK 1*X (seventh) LINK -1* (fifth) LINK -1*x (sixth)) ;
    </screen>

    <section id="test-mark-set">
      <title>Set Mark</title>
      <para>
        'X' sets the mark to the currently active cohort of the test's target.
        If no test sets X then the mark defaults to the cohort from the rule's target.
      </para>
    </section>

    <section id="test-mark-jump">
      <title>Jump to Mark</title>
      <para>
        'x' jumps back to the previously set mark (or the rule's target if no mark is set), then proceeds from there.
      </para>
    </section>
  </section>

  <section id="test-origin">
    <title>Scanning Past Point of Origin</title>
    <indexterm>
      <primary>--no-pass-origin</primary>
      <secondary>-o</secondary>
    </indexterm>
    <indexterm>
      <primary>O</primary>
    </indexterm>
    <indexterm>
      <primary>o</primary>
    </indexterm>
    <para>
      By default, linked scanning tests are allowed to scan past the point of origin.
      These options affect behavior.
    </para>

    <section id="test-origin-cmdline">
      <title>--no-pass-origin, -o</title>
      <para>
        The --no-pass-origin (or -o in short form) changes the default mode to not allow passing the origin,
        and defines the origin as the target of the currently active rule.
        This is equivalent to adding 'O' to the first test of each contextual test of all rules.
      </para>
    </section>

    <section id="test-no-pass-origin">
      <title>No Pass Origin</title>
      <para>
        'O' sets the point of origin to the parent of the contextual test, and disallows itself and all linked
        tests to pass this point of origin. The reason it sets it to the parent is that otherwise there is no
        way to mark the rule's target as the desired origin.
      </para>
      <screen>
        # Will not pass the (origin) cohort when looking for (right):
        SELECT (origin) IF (-1*O (left) LINK 1* (right)) ;

        # Will not pass the (origin) cohort when looking for (left):
        SELECT (something) IF (-1* (origin) LINK 1*O (right) LINK -1* (left)) ;
      </screen>
    </section>

    <section id="test-pass-origin">
      <title>Pass Origin</title>
      <para>
        'o' allows the contextual test and all its linked tests to pass the point of origin,
        even in --no-pass-origin mode. Used to counter 'O'.
      </para>
      <screen>
        # Will pass the (origin) cohort when looking for (right), but not when looking for (middle):
        SELECT (origin) IF (-1*O (left) LINK 1* (middle) LINK 1*o (right)) ;
      </screen>
    </section>
  </section>

  <section id="test-nearest">
    <title>Nearest Neighbor</title>
    <para>
      Usually a '*' or '**' test scans in only one direction, denoted by the value of the offset;
      if offset is positive it will scan rightwards, and if negative leftwards.
      In CG-3 the magic offset '0' will scan in both directions;
      first one to the left, then one to the right, then two to the left, then two to the right, etc.
      This makes it easy to find the nearest neighbor that matches.
      <emphasis>
        In earlier versions of CG this could be approximated with two seperate rules, and you
        had to scan entirely in one direction, then come back and do the other direction.
      </emphasis>
    </para>
    <screen>
      (0* (someset))
      (0**W (otherset))
    </screen>
  </section>

  <section id="test-dependency">
    <title>Dependencies</title>
    <indexterm>
      <primary>p</primary>
    </indexterm>
    <indexterm>
      <primary>c</primary>
    </indexterm>
    <indexterm>
      <primary>s</primary>
    </indexterm>
    <para>
      CG-3 also introduces the p, c, and s positions.
      See the section about those in the <link linkend="dep-contextual-tests">Dependencies</link> chapter.
    </para>
  </section>

</chapter>
